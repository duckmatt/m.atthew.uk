<html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      m.atthew.uk - Faster Python Protobuf
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif"/>
    <link rel="stylesheet" type="text/css" href="/style/normalize.css"/>
    <link rel="stylesheet" type="text/css" href="/style/style.css"/>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="/">
            Home
          </a>
          <a class="navbar-item" href="/about.html">
            About
          </a>
        </div>
      </div>
    </nav>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <h1 class="title article-title">
                  <a href="/posts/post.html">
                    Faster Python Protobuf
                  </a>
                </h1>
                <span class="subtitle is-6 article-subtitle">
                  Published on 2020-01-04
                </span>
              </div>
              <div class="content article-body">
                <p>It's no secret and no surprise that Protobuf in Python is slower than its Java and C++ counterparts, <a href="https://github.com/protocolbuffers/protobuf/blob/02a4c720c31af4e028469362b7e43b04ab2d2d4e/docs/performance.md">here's the official benchmarks</a>. However if you look at those benchmarks there is what appears to be a secret, at least as far as the documentation goes, in the benchmarks it goes by the column header: &quot;C++-generated-code&quot;.</p>
<!--more-->
<p>The benchmarks list three variants for Python: &quot;C++-generated-code&quot;, &quot;C++-reflection&quot;, and &quot;pure-Python&quot;. A little bit about these:</p>
<ul>
<li>Pure Python is the Protobuf library implemented in Python alone, understandably not performant.</li>
<li>C++ reflection is the Protobuf library but makes use of a Python extension which links to the C++ Protobuf library (<code>libprotobuf.so</code>), this gives a significant boost to performance over the Python library, orders of magnitude faster than the pure Python variant (roughly 10x).</li>
<li>C++ generated code links to C++ libraries which have been generated from the proto, for serialisation this is faster yet again but not to quite the same extent (roughly 5x for serialisation and 2x for parsing).</li>
</ul>
<h2>So which of these variants do we get when we install protobuf via pip?</h2>
<p>If your pip is hitting PyPi (default) you're going to be picking up one of the <a href="https://pypi.org/project/protobuf/#files">wheels packages</a>, each of the wheels that are specific about their platform make use of the &quot;C++-reflection&quot; variant - you're likely to be picking up one of these. However of course not every platform is covered, for this the &quot;pure-Python&quot; variant is used as a fallback, so you need to be careful that you're not going to suddenly get undetected performance regressions which would <a href="https://github.com/protocolbuffers/protobuf/issues/6214">happen today if you updated Python 3.7 to Python 3.8 on Windows for example</a>. You can detect if you're using &quot;C++-reflection&quot; or &quot;pure-Python&quot; using:</p>
<pre><code class="language-bash">python -c &quot;from google.protobuf.internal import api_implementation; print(api_implementation._default_implementation_type)&quot;
</code></pre>
<p>The above will print either <code>cpp</code> or <code>python</code>, note that it's using an internal api so there's no guarantee this won't break in future versions of the Protobuf library.</p>
<h2>So what about the faster &quot;C++-generated-code&quot; variant?</h2>
<p>Disclaimer: This variant is a bit more involved, unless you know need the additional performance I wouldn't recommend it.</p>
<p>To make use of generated C++ libraries from your protos from the Python library requires magic. The gist of it is that the C++ Protobuf library contains what's named a <code>DescriptorPool</code>, this is global and contains descriptions of all loaded Protobuf messages. The generated C++ code hooks into this by <a href="https://github.com/protocolbuffers/protobuf/blob/5c028d6cf42e426d47f5baa6ea3f0f5c86b97beb/src/google/protobuf/any.pb.cc#L81">adding the description of the message to the pool</a>. The Python library that links to the C++ library via a Python extension can make use of the global description pool from the C++ library. <em>Note description this may not be 100% accurate and there's more involved, but this is the gist of how it's functioning.</em></p>
<p>So, what we need is to load the C++ libraries generated from your <code>.proto</code> files before importing your generated Python code. This will get the C++ code for the messages added into the global descriptor pool which the Python library is then able to use. Which leads to the question, how do we load the C++ libraries? A. A Python extension that links to the C++ Protobuf library and to the generated C++ library.</p>
<p>There's a gotcha with this. For this to work both your extension and the Protobuf library need to be making use of the same globals - they need to be linked to the same <code>libprotobuf</code> library. But the wheels packages on PyPi do not dynamically link, they appear to have been statically linked to <code>libprotobuf</code>: <a href="https://github.com/protocolbuffers/protobuf/blob/26c0fbc15bd2ed8371df3f737951804f0a92db4b/python/setup.py#L185">setup.py</a>.</p>
<p>We need to build the Protobuf Library ourselves. There's a few ways to do this, for example cloning the Protobuf git repository and building from source. Or another method, install <code>libprotobuf</code> and grab the source from <code>PyPi</code> an, example:</p>
<pre><code class="language-bash"># Install C++ Protobuf Library and headers
sudo apt-get install libprotobuf-dev

# Download source from PyPi (alternatively clone the git repo for latest)
python -m pip download --no-deps --no-binary=protobuf protobuf
mkdir protobuf
tar xzf protobuf-*.tar.gz -C protobuf --strip-components 1

# Install Python Protobuf Library with --cpp_implementation but importantly not --compile_static_extension
cd protobuf
python setup.py install --user --cpp_implementation
</code></pre>
<p><em>Complete example + benchmarks coming soon</em></p>
<p><em>Note this was written at 2021-01-04, the situation may have changed since - all links are provided are the latest commits on the relevant files at the time of writing.</em></p>

              </div>
              <span></span>
            </div>
          </div>
        </div>
      </section>
    </div>
  </body>
</html>